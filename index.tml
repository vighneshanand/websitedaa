<header class="entry-header"><header class="entry-header">
<h1 class="entry-title">Data Structures</h1>
</header>
<div>&nbsp;</div>
<p>A&nbsp;<strong>data structure</strong>&nbsp;is a particular way of organizing data in a computer so that it can be used effectively.</p>
<p>For example, we can store a list of items having the same data-type using the&nbsp;<em>array</em>&nbsp;data structure.</p>
<div class="wp-caption aligncenter"><img class="size-large" src="https://media.geeksforgeeks.org/wp-content/uploads/array-2.png" width="429" height="195" />
<p class="wp-caption-text">Array Data Structure</p>
</div>
<p>This page contains detailed tutorials on different data structures (DS) with topic-wise problems.</p>
<p><strong>Topics:</strong></p>
<div>
<div>
<ul>
<li><a href="https://www.geeksforgeeks.org/array/">Array</a></li>
<li><a href="https://www.geeksforgeeks.org/data-structures/linked-list/">Linked List</a></li>
<li><a href="https://www.geeksforgeeks.org/stack/">Stack</a></li>
<li><a href="https://www.geeksforgeeks.org/queue/">Queue</a></li>
</ul>
</div>
<div>
<ul>
<li><a href="https://www.geeksforgeeks.org/binary-tree-2/">Binary Tree</a></li>
<li><a href="https://www.geeksforgeeks.org/binary-search-tree/">Binary Search Tree</a></li>
<li><a href="https://www.geeksforgeeks.org/heap/">Heap</a></li>
<li><a href="https://www.geeksforgeeks.org/hashing/">Hashing</a></li>
</ul>
</div>
<div>
<ul>
<li><a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph</a></li>
<li><a href="https://www.geeksforgeeks.org/matrix/">Matrix</a></li>
<li><a href="https://www.geeksforgeeks.org/data-structures/#Misc">Misc</a></li>
<li><a href="https://www.geeksforgeeks.org/data-structures/#AdvancedDataStructure">Advanced Data Structure</a></li>
</ul>
</div>
</div>
<h1 class="entry-title">Linked List&nbsp; (Introduction)</h1>
</header>
<div class="entry-content">
<p>Like arrays, Linked List is a linear data structure. Unlike arrays, linked list elements are not stored at a contiguous location; the elements are linked using pointers.</p>
<p><a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2013/03/Linkedlist.png"><img class="aligncenter size-full wp-image-28023" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2013/03/Linkedlist.png" alt="linkedlist" width="500" height="56" /></a></p>
<p><strong>Why Linked List?</strong><br />Arrays can be used to store linear data of similar types, but arrays have the following limitations.<br /><strong>1)</strong>&nbsp;The size of the arrays is fixed: So we must know the upper limit on the number of elements in advance. Also, generally, the allocated memory is equal to the upper limit irrespective of the usage.<br /><strong>2)</strong>&nbsp;Inserting a new element in an array of elements is expensive because the room has to be created for the new elements and to create room existing elements have to be shifted.</p>
<div id="AP_G4GR_5">
<div id="c9541d0b-2b1f-47f8-8b8b-63e4e11f2de9" class="_ap_apex_ad" data-section="c9541d0b-2b1f-47f8-8b8b-63e4e11f2de9" data-xpath="#AP_G4GR_5" data-section-id="" data-render-time="1587809085900" data-refresh-time="1587809092358" data-timeout="142">
<div id="ADP_40792_728X280_c9541d0b-2b1f-47f8-8b8b-63e4e11f2de9" data-google-query-id="CNzfveWpg-kCFS0KtwAdPosOFw">
<div id="google_ads_iframe_/103512698/21930050872_0__container__">For example, in a system, if we maintain a sorted list of IDs in an array id[].</div>
</div>
</div>
</div>
<p>id[] = [1000, 1010, 1050, 2000, 2040].</p>
<p>And if we want to insert a new ID 1005, then to maintain the sorted order, we have to move all the elements after 1000 (excluding 1000).<br />Deletion is also expensive with arrays until unless some special techniques are used. For example, to delete 1010 in id[], everything after 1010 has to be moved.</p>
<p><strong>Advantages over arrays</strong><br /><strong>1)</strong>&nbsp;Dynamic size<br /><strong>2)</strong>&nbsp;Ease of insertion/deletion</p>
<p><strong>Drawbacks:</strong><br /><strong>1)</strong>&nbsp;Random access is not allowed. We have to access elements sequentially starting from the first node. So we cannot do binary search with linked lists efficiently with its default implementation. Read about it&nbsp;<a href="https://www.geeksforgeeks.org/binary-search-on-singly-linked-list/" target="_blank" rel="noopener">here</a>.<br /><strong>2)</strong>&nbsp;Extra memory space for a pointer is required with each element of the list.<br /><strong>3)</strong>&nbsp;Not cache friendly. Since array elements are contiguous locations, there is locality of reference which is not there in case of linked lists.</p>
<p><strong>Representation:</strong><br />A linked list is represented by a pointer to the first node of the linked list. The first node is called the head. If the linked list is empty, then the value of the head is NULL.<br />Each node in a list consists of at least two parts:<br />1) data<br />2) Pointer (Or Reference) to the next node<br />In C, we can represent a node using structures. Below is an example of a linked list node with integer data.<br />In Java or C#, LinkedList can be represented as a class and a Node as a separate class. The LinkedList class contains a reference of Node class type.</p>
<div class="noIdeBtnDiv">
<div class="responsive-tabs-wrapper">
<div class="responsive-tabs responsive-tabs--enabled">
<div id="tablist1-panel1" class="tabcontent responsive-tabs__panel responsive-tabs__panel--active" role="tabpanel" aria-hidden="false" aria-labelledby="tablist1-tab1">
<div class="code-block">
<div class="code-container">
<div id="highlighter_306798" class="syntaxhighlighter nogutter  ">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="comments">// A linked list node </code></div>
<div class="line number2 index1 alt1"><code class="keyword bold">struct</code> <code class="plain">Node { </code></div>
<div class="line number3 index2 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">data; </code></div>
<div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Node* next; </code></div>
<div class="line number5 index4 alt2"><code class="plain">}; </code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="noIdeBtnDiv">
<div class="responsive-tabs-wrapper">
<div class="responsive-tabs responsive-tabs--enabled">
<div id="tablist2-panel1" class="tabcontent responsive-tabs__panel responsive-tabs__panel--active" role="tabpanel" aria-hidden="false" aria-labelledby="tablist2-tab1">
<div class="code-block">
<div class="code-gutter">&nbsp;</div>
<div class="code-container">
<div id="highlighter_832762" class="syntaxhighlighter nogutter  ">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="comments">// A simple CPP program to introduce </code></div>
<div class="line number2 index1 alt1"><code class="comments">// a linked list </code></div>
<div class="line number3 index2 alt2"><code class="preprocessor">#include &lt;bits/stdc++.h&gt; </code></div>
<div class="line number4 index3 alt1"><code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code></div>
<div class="line number5 index4 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number6 index5 alt1"><code class="keyword bold">class</code> <code class="plain">Node { </code></div>
<div class="line number7 index6 alt2"><code class="keyword bold">public</code><code class="plain">: </code></div>
<div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">data; </code></div>
<div class="line number9 index8 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* next; </code></div>
<div class="line number10 index9 alt1"><code class="plain">}; </code></div>
<div class="line number11 index10 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number12 index11 alt1"><code class="comments">// Program to create a simple linked </code></div>
<div class="line number13 index12 alt2"><code class="comments">// list with 3 nodes </code></div>
<div class="line number14 index13 alt1"><code class="color1 bold">int</code> <code class="plain">main() </code></div>
<div class="line number15 index14 alt2"><code class="plain">{ </code></div>
<div class="line number16 index15 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* head = NULL; </code></div>
<div class="line number17 index16 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* second = NULL; </code></div>
<div class="line number18 index17 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* third = NULL; </code></div>
<div class="line number19 index18 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number20 index19 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// allocate 3 nodes in the heap </code></div>
<div class="line number21 index20 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">head = </code><code class="keyword bold">new</code> <code class="plain">Node(); </code></div>
<div class="line number22 index21 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">second = </code><code class="keyword bold">new</code> <code class="plain">Node(); </code></div>
<div class="line number23 index22 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">third = </code><code class="keyword bold">new</code> <code class="plain">Node(); </code></div>
<div class="line number24 index23 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number25 index24 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Three blocks have been allocated dynamically.&nbsp; </code></div>
<div class="line number26 index25 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">We have pointers to these three blocks as head,&nbsp; </code></div>
<div class="line number27 index26 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">second and third&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>
<div class="line number28 index27 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; second&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; third&nbsp; </code></div>
<div class="line number29 index28 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; </code></div>
<div class="line number30 index29 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; </code></div>
<div class="line number31 index30 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+-----+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp; </code></div>
<div class="line number32 index31 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">| # | # |&nbsp;&nbsp;&nbsp;&nbsp; | # | # |&nbsp;&nbsp;&nbsp;&nbsp; | # | # |&nbsp; </code></div>
<div class="line number33 index32 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+-----+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp; </code></div>
<div class="line number34 index33 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number35 index34 alt2"><code class="comments"># represents any random value.&nbsp; </code></div>
<div class="line number36 index35 alt1"><code class="comments">Data is random because we haven&rsquo;t assigned&nbsp; </code></div>
<div class="line number37 index36 alt2"><code class="comments">anything yet */</code></div>
<div class="line number38 index37 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number39 index38 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">head-&gt;data = 1; </code><code class="comments">// assign data in first node </code></div>
<div class="line number40 index39 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">head-&gt;next = second; </code><code class="comments">// Link first node with </code></div>
<div class="line number41 index40 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the second node </code></div>
<div class="line number42 index41 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number43 index42 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* data has been assigned to the data part of first&nbsp; </code></div>
<div class="line number44 index43 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">block (block pointed by the head). And next&nbsp; </code></div>
<div class="line number45 index44 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">pointer of the first block points to second.&nbsp; </code></div>
<div class="line number46 index45 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">So they both are linked.&nbsp; </code></div>
<div class="line number47 index46 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number48 index47 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; second&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; third&nbsp; </code></div>
<div class="line number49 index48 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; </code></div>
<div class="line number50 index49 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; </code></div>
<div class="line number51 index50 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+---+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp;&nbsp;&nbsp;&nbsp; +-----+----+&nbsp; </code></div>
<div class="line number52 index51 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">| 1 | o-----&gt;| # | # |&nbsp;&nbsp;&nbsp;&nbsp; | # | # |&nbsp; </code></div>
<div class="line number53 index52 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+---+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp;&nbsp;&nbsp;&nbsp; +-----+----+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>
<div class="line number54 index53 alt1"><code class="comments">*/</code></div>
<div class="line number55 index54 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number56 index55 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// assign data to second node </code></div>
<div class="line number57 index56 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">second-&gt;data = 2; </code></div>
<div class="line number58 index57 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number59 index58 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Link second node with the third node </code></div>
<div class="line number60 index59 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">second-&gt;next = third; </code></div>
<div class="line number61 index60 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number62 index61 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* data has been assigned to the data part of the second&nbsp; </code></div>
<div class="line number63 index62 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">block (block pointed by second). And next&nbsp; </code></div>
<div class="line number64 index63 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">pointer of the second block points to the third&nbsp; </code></div>
<div class="line number65 index64 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">block. So all three blocks are linked.&nbsp; </code></div>
<div class="line number66 index65 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number67 index66 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; second&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; third&nbsp; </code></div>
<div class="line number68 index67 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; </code></div>
<div class="line number69 index68 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; </code></div>
<div class="line number70 index69 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+---+&nbsp;&nbsp;&nbsp;&nbsp; +---+---+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp; </code></div>
<div class="line number71 index70 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">| 1 | o-----&gt;| 2 | o-----&gt; | # | # |&nbsp; </code></div>
<div class="line number72 index71 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+---+&nbsp;&nbsp;&nbsp;&nbsp; +---+---+&nbsp;&nbsp;&nbsp;&nbsp; +----+----+&nbsp;&nbsp;&nbsp;&nbsp; */</code></div>
<div class="line number73 index72 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number74 index73 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">third-&gt;data = 3; </code><code class="comments">// assign data to third node </code></div>
<div class="line number75 index74 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">third-&gt;next = NULL; </code></div>
<div class="line number76 index75 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number77 index76 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* data has been assigned to the data part of the third&nbsp; </code></div>
<div class="line number78 index77 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">block (block pointed by third). And next pointer&nbsp; </code></div>
<div class="line number79 index78 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">of the third block is made NULL to indicate&nbsp; </code></div>
<div class="line number80 index79 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">that the linked list is terminated here.&nbsp; </code></div>
<div class="line number81 index80 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number82 index81 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">We have the linked list ready.&nbsp; </code></div>
<div class="line number83 index82 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number84 index83 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>
<div class="line number85 index84 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp; </code></div>
<div class="line number86 index85 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">|&nbsp; </code></div>
<div class="line number87 index86 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+---+&nbsp;&nbsp;&nbsp;&nbsp; +---+---+&nbsp;&nbsp;&nbsp;&nbsp; +----+------+&nbsp; </code></div>
<div class="line number88 index87 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">| 1 | o-----&gt;| 2 | o-----&gt; | 3 | NULL |&nbsp; </code></div>
<div class="line number89 index88 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">+---+---+&nbsp;&nbsp;&nbsp;&nbsp; +---+---+&nbsp;&nbsp;&nbsp;&nbsp; +----+------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div>
<div class="line number90 index89 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number91 index90 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number92 index91 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">Note that only the head is sufficient to represent&nbsp; </code></div>
<div class="line number93 index92 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">the whole list. We can traverse the complete&nbsp; </code></div>
<div class="line number94 index93 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">list by following the next pointers. */</code></div>
<div class="line number95 index94 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number96 index95 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code></div>
<div class="line number97 index96 alt2"><code class="plain">} </code></div>
<div class="line number98 index97 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number99 index98 alt2"><code class="comments">// This code is contributed by rathbhupendra </code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p><strong>Linked List Traversal</strong><br />In the previous program, we have created a simple linked list with three nodes. Let us traverse the created list and print the data of each node. For traversal, let us write a general-purpose function printList() that prints any given list.</p>
<div class="responsive-tabs-wrapper">
<div class="responsive-tabs responsive-tabs--enabled">
<div id="tablist3-panel1" class="tabcontent responsive-tabs__panel responsive-tabs__panel--active" role="tabpanel" aria-hidden="false" aria-labelledby="tablist3-tab1">
<div class="code-block">
<div class="code-gutter">&nbsp;</div>
<div class="code-container">
<div id="highlighter_830213" class="syntaxhighlighter nogutter  ">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="comments">// A simple C++ program for traversal of a linked list </code></div>
<div class="line number2 index1 alt1"><code class="preprocessor">#include &lt;bits/stdc++.h&gt; </code></div>
<div class="line number3 index2 alt2"><code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code></div>
<div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number5 index4 alt2"><code class="keyword bold">class</code> <code class="plain">Node { </code></div>
<div class="line number6 index5 alt1"><code class="keyword bold">public</code><code class="plain">: </code></div>
<div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">data; </code></div>
<div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* next; </code></div>
<div class="line number9 index8 alt2"><code class="plain">}; </code></div>
<div class="line number10 index9 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number11 index10 alt2"><code class="comments">// This function prints contents of linked list </code></div>
<div class="line number12 index11 alt1"><code class="comments">// starting from the given node </code></div>
<div class="line number13 index12 alt2"><code class="keyword bold">void</code> <code class="plain">printList(Node* n) </code></div>
<div class="line number14 index13 alt1"><code class="plain">{ </code></div>
<div class="line number15 index14 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(n != NULL) { </code></div>
<div class="line number16 index15 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; n-&gt;data &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code></div>
<div class="line number17 index16 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n = n-&gt;next; </code></div>
<div class="line number18 index17 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code></div>
<div class="line number19 index18 alt2"><code class="plain">} </code></div>
<div class="line number20 index19 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number21 index20 alt2"><code class="comments">// Driver code </code></div>
<div class="line number22 index21 alt1"><code class="color1 bold">int</code> <code class="plain">main() </code></div>
<div class="line number23 index22 alt2"><code class="plain">{ </code></div>
<div class="line number24 index23 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* head = NULL; </code></div>
<div class="line number25 index24 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* second = NULL; </code></div>
<div class="line number26 index25 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Node* third = NULL; </code></div>
<div class="line number27 index26 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number28 index27 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// allocate 3 nodes in the heap </code></div>
<div class="line number29 index28 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">head = </code><code class="keyword bold">new</code> <code class="plain">Node(); </code></div>
<div class="line number30 index29 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">second = </code><code class="keyword bold">new</code> <code class="plain">Node(); </code></div>
<div class="line number31 index30 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">third = </code><code class="keyword bold">new</code> <code class="plain">Node(); </code></div>
<div class="line number32 index31 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number33 index32 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">head-&gt;data = 1; </code><code class="comments">// assign data in first node </code></div>
<div class="line number34 index33 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">head-&gt;next = second; </code><code class="comments">// Link first node with second </code></div>
<div class="line number35 index34 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number36 index35 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">second-&gt;data = 2; </code><code class="comments">// assign data to second node </code></div>
<div class="line number37 index36 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">second-&gt;next = third; </code></div>
<div class="line number38 index37 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number39 index38 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">third-&gt;data = 3; </code><code class="comments">// assign data to third node </code></div>
<div class="line number40 index39 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">third-&gt;next = NULL; </code></div>
<div class="line number41 index40 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number42 index41 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printList(head); </code></div>
<div class="line number43 index42 alt2"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number44 index43 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code></div>
<div class="line number45 index44 alt2"><code class="plain">} </code></div>
<div class="line number46 index45 alt1"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number47 index46 alt2"><code class="comments">// This is code is contributed by rathbhupendra </code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<br /><strong>Output:</strong>
<pre>1  2  3<br /><br /><br /><br /><br /></pre>
<h1 class="h1">Hashing</h1>
<p>Hashing is the transformation of a string of character into a usually shorter fixed-length value or key that represents the original string.</p>
<p>Hashing is used to index and retrieve items in a database because it is faster to find the item using the shortest hashed key than to find it using the original value. It is also used in many encryption algorithms.</p>
<p>A hash code is generated by using a key, which is a unique value.</p>
<p>Hashing is a technique in which given key field value is converted into the address of storage location of the record by applying the same operation on it.</p>
<p>The advantage of hashing is that allows the execution time of basic operation to remain constant even for the larger side.</p>
<h2 class="h2">Why we need Hashing?</h2>
<p>Suppose we have 50 employees, and we have to give 4 digit key to each employee (as for security), and we want after entering a key, direct user map to a particular position where data is stored.</p>
<p>If we give the location number according to 4 digits, we will have to reserve 0000 to 9999 addresses because anybody can use anyone as a key. There is a lot of wastage.</p>
<p>In order to solve this problem, we use hashing which will produce a smaller value of the index of the hash table corresponding to the key of the user.</p>
<h2 class="h2">Universal Hashing</h2>
<p>Let H be a finite collection of hash functions that map a given universe U of keys into the range {0, 1..... m-1}. Such a collection is said to be universal if for each pair of distinct keys k,l&isin;U, the number of hash functions h&isin; H for which h(k)= h(l) is at most |H|/m. In other words, with a hash function randomly chosen from H, the chance of a collision between distinct keys k and l is no more than the chance 1/m of a collision if h(k) and h(l)were randomly and independently chosen from the set {0,1,...m-1}.</p>
<h2 class="h2">Rehashing</h2>
<p>If any stage the hash table becomes nearly full, the running time for the operations of will start taking too much time, insert operation may fail in such situation, the best possible solution is as follows:</p>
<ol class="points">
<li>Create a new hash table double in size.</li>
<li>Scan the original hash table, compute new hash value and insert into the new hash table.</li>
<li>Free the memory occupied by the original hash table.</li>
</ol>
<p><strong>Example:</strong>&nbsp;Consider inserting the keys 10, 22, 31,4,15,28,17,88 and 59 into a hash table of length m = 11 using open addressing with the primary hash function h' (k) = k mod m .Illustrate the result of inserting these keys using linear probing, using quadratic probing with c<sub>1</sub>=1 and c<sub>2</sub>=3, and using double hashing with h<sub>2</sub>(k) = 1 + (k mod (m-1)).</p>
<p><strong>Solution:</strong>&nbsp;Using Linear Probing the final state of hash table would be:</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/rehashing-solution.png" alt="DAA Hashing" /></p>
<p>Using Quadratic Probing with c<sub>1</sub>=1, c<sub>2</sub>=3, the final state of hash table would be h (k, i) = (h' (k) +c<sub>1</sub>*i+ c<sub>2</sub>&nbsp;*i<sup>2</sup>) mod m where m=11 and h' (k) = k mod m.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/rehashing-solution2.png" alt="DAA Hashing" /></p>
<p>Using Double Hashing, the final state of the hash table would be:</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/rehashing-solution3.png" alt="DAA Hashing" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 class="h1">Hash Tables</h1>
<p>It is a collection of items which are stored in such a way as to make it easy to find them later.</p>
<p>Each position in the hash table is called slot, can hold an item and is named by an integer value starting at 0.</p>
<p>The mapping between an item and a slot where the item belongs in a hash table is called a Hash Function. A hash Function accepts a key and returns its hash coding, or hash value.</p>
<p>Assume we have a set of integers 54, 26, 93, 17, 77, 31. Our first hash function required to be as "remainder method" simply takes the item and divide it by table size, returning remainder as its hash value i.e.</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">&nbsp;</div>
<ol class="dp-j" start="1">
<li class="alt">&nbsp;&nbsp;&nbsp;h&nbsp;item&nbsp;=&nbsp;item&nbsp;%&nbsp;(size&nbsp;of&nbsp;table)&nbsp;&nbsp;&nbsp;</li>
<li class="">Let&nbsp;us&nbsp;say&nbsp;the&nbsp;size&nbsp;of&nbsp;table&nbsp;=&nbsp;<span class="number">11</span>,&nbsp;then&nbsp;&nbsp;</li>
<li class="alt"><span class="number">54</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">10</span>&nbsp;&nbsp;&nbsp;<span class="number">26</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">4</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="number">93</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">5</span>&nbsp;&nbsp;</li>
<li class=""><span class="number">17</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">6</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="number">77</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">0</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="number">31</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">9</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>&nbsp;</p>
<table class="alt">
<tbody>
<tr>
<th>ITEM</th>
<th>HASH VALUE</th>
</tr>
<tr>
<td>54</td>
<td>10</td>
</tr>
<tr>
<td>26</td>
<td>4</td>
</tr>
<tr>
<td>93</td>
<td>5</td>
</tr>
<tr>
<td>17</td>
<td>6</td>
</tr>
<tr>
<td>77</td>
<td>0</td>
</tr>
<tr>
<td>31</td>
<td>9</td>
</tr>
</tbody>
</table>
<p><br /><img src="https://static.javatpoint.com/tutorial/daa/images/daa-hash-table.png" alt="DAA Hash Tables" /></p>
<p>Now when we need to search any element, we just need to divide it by the table size, and we get the hash value. So we get the O (1) search time.</p>
<p>Now taking one more element 44 when we apply the hash function on 44, we get (44 % 11 = 0), But 0 hash value already has an element 77. This Problem is called as Collision.</p>
<p><strong>Collision:</strong>&nbsp;According to the Hash Function, two or more item would need in the same slot. This is said to be called as Collision.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/daa-hash-table-collision.png" alt="DAA Hash Tables" /></p>
<p><strong>Figure:</strong>&nbsp;using a hash function h to map keys to hash-table slots. Because keys K2 and k5 map to the same slot, they collide.</p>
<h2 class="h2">Why use HashTable?</h2>
<ol class="points">
<li>If&nbsp;<strong>U</strong>&nbsp;(Universe of keys) is large, storing a table T of size [U] may be impossible.</li>
<li>Set&nbsp;<strong>k</strong>&nbsp;of keys may be small relative to&nbsp;<strong>U</strong>&nbsp;so space allocated for&nbsp;<strong>T</strong>&nbsp;will waste.</li>
</ol>
<p>So Hash Table requires less storage. Indirect addressing element with key k is stored in slot k with hashing it is stored in h (k) where h is a hash f<sup>n</sup>&nbsp;and hash (k) is the value of key k. Hash f<sup>n</sup>&nbsp;required array range.</p>
<h2 class="h2">Application of Hash Tables:</h2>
<p>Some application of Hash Tables are:</p>
<ol class="points">
<li><strong>Database System:</strong>&nbsp;Specifically, those that are required efficient random access. Usually, database systems try to develop between two types of access methods: sequential and random. Hash Table is an integral part of efficient random access because they provide a way to locate data in a constant amount of time.</li>
<li><strong>Symbol Tables:</strong>&nbsp;The tables utilized by compilers to maintain data about symbols from a program. Compilers access information about symbols frequently. Therefore, it is essential that symbol tables be implemented very efficiently.</li>
<li><strong>Data Dictionaries:</strong>&nbsp;Data Structure that supports adding, deleting, and searching for data. Although the operation of hash tables and a data dictionary are similar, other Data Structures may be used to implement data dictionaries.</li>
<li><strong>Associative Arrays:</strong>&nbsp;Associative Arrays consist of data arranged so that n<sup>th</sup>&nbsp;elements of one array correspond to the n<sup>th</sup>&nbsp;element of another. Associative Arrays are helpful for indexing a logical grouping of data by several key fields.</li>
</ol>
<header class="entry-header"></header>
<div class="algo"><header class="entry-header">
<h1 class="entry-title">Sorting Terminology</h1>
</header>
<div class="entry-content">
<p><strong>What is in-place sorting?</strong><br />An in-place sorting algorithm uses constant extra space for producing the output (modifies the given array only). It sorts the list only by modifying the order of the elements within the list.<br />For example, Insertion Sort and Selection Sorts are in-place sorting algorithms as they do not use any additional space for sorting the list and a typical implementation of Merge Sort is not in-place, also the implementation for counting sort is not in-place sorting algorithm.</p>
<p><strong>What are Internal and External Sortings?</strong><br />When all data that needs to be sorted cannot be placed in-memory at a time, the sorting is called&nbsp;<a href="http://en.wikipedia.org/wiki/External_sorting" target="_blank" rel="noopener">external sorting</a>. External Sorting is used for massive amount of data. Merge Sort and its variations are typically used for external sorting. Some external storage like hard-disk, CD, etc is used for external storage.<br />When all data is placed in-memory, then sorting is called internal sorting.</p>
<p><strong>What is stable sorting?</strong><br />See&nbsp;<a href="https://www.geeksforgeeks.org/stability-in-sorting-algorithms/">Stable Sorting Algorithms</a></p>
<p>&nbsp;</p>
<h1 class="h1">Introduction of Backtracking</h1>
<p>The Backtracking is an algorithmic-method to solve a problem with an additional way. It uses a recursive approach to explain the problems. We can say that the backtracking is needed to find all possible combination to solve an optimization problem.</p>
<p><strong>Backtracking</strong>&nbsp;is a systematic way of trying out different sequences of decisions until we find one that "works."</p>
<p>In the following figure</p>
<p>Each non-leaf node in a tree is a parent of one or more other nodes (its children)</p>
<ul class="points">
<li>Each node in the tree, other than the root, has exactly one parent</li>
</ul>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/backtracking-introduction.png" alt="Backtracking Introduction" /></p>
<p>Generally, however, we draw our trees downward, with the root at the top.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/backtracking-introduction2.png" alt="Backtracking Introduction" /></p>
<p>A tree is composed of nodes.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/backtracking-introduction3.png" alt="Backtracking Introduction" /></p>
<p><strong>Backtracking can understand of as searching a tree for a particular "goal" leaf node.</strong></p>
<p>Backtracking is undoubtedly quite simple - we "explore" each node, as follows:</p>
<div class="codeblock">
<pre><strong>To "explore" node N:</strong> 1. If N is a goal node, return "success" 2. If N is a leaf node, return "failure" 3. For each child C of N,     Explore C     If C was successful, return "success" 4. Return "failure"</pre>
</div>
<p>Backtracking algorithm determines the solution by systematically searching the solution space for the given problem. Backtracking is a&nbsp;<strong>depth-first search</strong>&nbsp;with any bounding function. All solution using backtracking is needed to satisfy a complex set of constraints. The constraints may be explicit or implicit.</p>
<p><strong>Explicit Constraint</strong>&nbsp;is ruled, which restrict each vector element to be chosen from the given set.</p>
<p><strong>Implicit Constraint</strong>&nbsp;is ruled, which determine which each of the tuples in the solution space, actually satisfy the criterion function. Figure:</p>
<p>&nbsp;&nbsp;</p>
<h1 class="h1">Recursive Maze Algorithm</h1>
<p>Recursive Maze Algorithm is one of the best examples for backtracking algorithms. Recursive Maze Algorithm is one of the possible solutions for solving the maze.</p>
<h2 class="h2">Maze</h2>
<p>The maze is an area surrounded by walls; in between, we have a path from starting point to ending position. We have to start from the starting point and travel towards from ending point.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/recursive-maze-algorithm.png" alt="Recursive Maze Algorithm" /></p>
<h2 class="h2">Principle of Maze</h2>
<p>As explained above, in the maze we have to travel from starting point to ending point. The problem is to choose the path. If we find any dead-end before ending point, we have to backtrack and move the direction. The direction for traversing is North, East, West, and South. We have to continue "move and backtrack" until we reach the final point.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Consider that we are having a two-dimensional maze cell [WIDTH] [HEIGHT]. Here cell [x] [y] = 1 denotes wall and cell [x] [y] = 0 denotes free cell in the particular location x, y in the maze. The directions we can change in the array are North, East, West, and South. The first step is to make the boundary of the two - dimensional array as one so that we won't go out of the maze and usually reside inside the maze at any time.</p>
<table class="alt">
<tbody>
<tr>
<th colspan="7">Example Maze</th>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Now start changing from the starting position (since the boundary is filled by 1) and find the next free cell then turn to the next free cell and so on. If we grasp a dead-end, we have to backtrack and make the cells in the path as 1 (wall). Continue the same process till the final point is reached.</p>
<header class="entry-header">
<h1 class="entry-title">XOR Linked List &ndash; A Memory Efficient Doubly Linked List | Set 1</h1>
</header>
<div class="entry-content">
<p>An ordinary Doubly Linked List requires space for two address fields to store the addresses of previous and next nodes.&nbsp;A memory efficient version of Doubly Linked List can be created using only one space for address field with every node. This memory efficient Doubly Linked List is called XOR Linked List or Memory Efficient as the list uses bitwise XOR operation to save space for one address. In the XOR linked list, instead of storing actual memory addresses, every node stores the XOR of addresses of previous and next nodes.</p>
<p><a href="https://media.geeksforgeeks.org/wp-content/uploads/XorLinkedList.jpg"><img class="aligncenter size-medium wp-image-12441" title="doublyll" src="https://media.geeksforgeeks.org/wp-content/uploads/XorLinkedList.jpg" alt="" width="500" height="105" /></a></p>
<p>Consider the above Doubly Linked List. Following are the Ordinary and XOR (or Memory Effiecient) representations of the Doubly Linked List.</p>
<br />
<div id="AP_G4GR_5">&nbsp;</div>
<br />
<p><strong>Ordinary Representation:</strong><br />Node A:<br />prev = NULL, next = add(B) // previous is NULL and next is address of B</p>
<p>Node B:<br />prev = add(A), next = add(C) // previous is address of A and next is address of C</p>
<p>Node C:<br />prev = add(B), next = add(D) // previous is address of B and next is address of D</p>
<p>Node D:<br />prev = add(C), next = NULL // previous is address of C and next is NULL</p>
<p><strong>XOR List Representation:</strong><br />Let us call the address variable in XOR representation npx (XOR of next and previous)</p>
<p>Node A:<br />npx = 0 XOR add(B) // bitwise XOR of zero and address of B</p>
<p>Node B:<br />npx = add(A) XOR add(C) // bitwise XOR of address of A and address of C</p>
<p>Node C:<br />npx = add(B) XOR add(D) // bitwise XOR of address of B and address of D</p>
<p>Node D:<br />npx = add(C) XOR 0 // bitwise XOR of address of C and 0</p>
<p><strong>Traversal of XOR Linked List:</strong><br />We can traverse the XOR list in both forward and reverse direction. While traversing the list we need to remember the address of the previously accessed node in order to calculate the next node&rsquo;s address. For example when we are at node C, we must have address of B. XOR of add(B) and&nbsp;<em>npx&nbsp;</em>of C gives us the add(D). The reason is simple: npx(C) is &ldquo;add(B) XOR add(D)&rdquo;. If we do xor of npx(C) with add(B), we get the result as &ldquo;add(B) XOR add(D) XOR add(B)&rdquo; which is &ldquo;add(D) XOR 0&rdquo; which is &ldquo;add(D)&rdquo;. So we have the address of next node. Similarly we can traverse the list in backward direction.</p>
<p>We have covered more on XOR Linked List in the following post.</p>
<p><a href="https://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-2/">XOR Linked List &ndash; A Memory Efficient Doubly Linked List | Set 2</a></p>
<p><strong>References:</strong><br /><a href="http://en.wikipedia.org/wiki/XOR_linked_list">http://en.wikipedia.org/wiki/XOR_linked_list</a><br /><a href="http://www.linuxjournal.com/article/6828?page=0,0">http://www.linuxjournal.com/article/6828?page=0,0</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<header class="entry-header">
<h1 class="entry-title">Binary Search Tree | Set 1 (Search and Insertion)</h1>
</header>
<div class="entry-content">
<p>The following is definition of Binary Search Tree(BST) according to&nbsp;<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">Wikipedia</a></p>
<p>Binary Search Tree, is a node-based binary tree data structure which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys lesser than the node&rsquo;s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node&rsquo;s key.</li>
<li>The left and right subtree each must also be a binary search tree.<br />There must be no duplicate nodes.</li>
</ul>
<p><img class="alignnone size-full wp-image-8934" src="https://media.geeksforgeeks.org/wp-content/uploads/BSTSearch.png" alt="200px-Binary_search_tree.svg" /></p>
<br />
<div id="AP_G4GR_5">&nbsp;</div>
<br />
<p>The above properties of Binary Search Tree provide an ordering among keys so that the operations like search, minimum and maximum can be done fast. If there is no ordering, then we may have to compare every key to search a given key.</p>
<br />
<div id="AP_G4GR_5">&nbsp;</div>
<br />
<p><strong>Searching a key</strong><br />To search a given key in Binary Search Tree, we first compare it with root, if the key is present at root, we return root. If key is greater than root&rsquo;s key, we recur for right subtree of root node. Otherwise we recur for left subtree</p>
<div class="responsive-tabs-wrapper">
<div class="responsive-tabs responsive-tabs--enabled">
<div id="tablist1-panel1" class="tabcontent responsive-tabs__panel responsive-tabs__panel--active" role="tabpanel" aria-hidden="false" aria-labelledby="tablist1-tab1">
<div class="code-block">
<div class="code-gutter">&nbsp;</div>
<div class="code-container">
<div id="highlighter_211540" class="syntaxhighlighter nogutter  ">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2 highlighted"><code class="comments">// C function to search a given key in a given BST </code></div>
<div class="line number2 index1 alt1 highlighted"><code class="keyword bold">struct</code> <code class="plain">node* search(</code><code class="keyword bold">struct</code> <code class="plain">node* root, </code><code class="color1 bold">int</code> <code class="plain">key) </code></div>
<div class="line number3 index2 alt2 highlighted"><code class="plain">{ </code></div>
<div class="line number4 index3 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Base Cases: root is null or key is present at root </code></div>
<div class="line number5 index4 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(root == NULL || root-&gt;key == key) </code></div>
<div class="line number6 index5 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">root; </code></div>
<div class="line number7 index6 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number8 index7 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Key is greater than root's key </code></div>
<div class="line number9 index8 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(root-&gt;key &lt; key) </code></div>
<div class="line number10 index9 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">search(root-&gt;right, key); </code></div>
<div class="line number11 index10 alt2 highlighted"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number12 index11 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Key is smaller than root's key </code></div>
<div class="line number13 index12 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">search(root-&gt;left, key); </code></div>
<div class="line number14 index13 alt1 highlighted"><code class="plain">} </code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<br /><strong>Illustration to search 6 in below tree:</strong><br />1. Start from root.<br />2. Compare the inserting element with root, if less than root, then recurse for left, else recurse for right.<br />3. If element to search is found anywhere, return true, else return false.<br /><img class="aligncenter size-full wp-image-27861" src="https://media.geeksforgeeks.org/wp-content/uploads/BSTSearch.png" alt="bstsearch" />
<p>&nbsp;</p>
<p><strong>Insertion of a key</strong><br />A new key is always inserted at leaf. We start searching a key from root till we hit a leaf node. Once a leaf node is found, the new node is added as a child of the leaf node.</p>
<pre>         100                               100
        /   \        Insert 40            /    \
      20     500    ---------&gt;          20     500 
     /  \                              /  \  
    10   30                           10   30
                                              \   
                                              40</pre>
<div class="responsive-tabs-wrapper">
<div class="responsive-tabs responsive-tabs--enabled">
<div id="tablist2-panel1" class="tabcontent responsive-tabs__panel responsive-tabs__panel--active" role="tabpanel" aria-hidden="false" aria-labelledby="tablist2-tab1">
<div class="code-block">
<div class="code-gutter">&nbsp;</div>
<div class="code-container">
<div id="highlighter_520790" class="syntaxhighlighter nogutter  ">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="comments">// C program to demonstrate insert operation in binary search tree. </code></div>
<div class="line number2 index1 alt1"><code class="preprocessor">#include&lt;stdio.h&gt; </code></div>
<div class="line number3 index2 alt2"><code class="preprocessor">#include&lt;stdlib.h&gt; </code></div>
<div class="line number4 index3 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number5 index4 alt2"><code class="keyword bold">struct</code> <code class="plain">node </code></div>
<div class="line number6 index5 alt1"><code class="plain">{ </code></div>
<div class="line number7 index6 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">key; </code></div>
<div class="line number8 index7 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">node *left, *right; </code></div>
<div class="line number9 index8 alt2"><code class="plain">}; </code></div>
<div class="line number10 index9 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number11 index10 alt2"><code class="comments">// A utility function to create a new BST node </code></div>
<div class="line number12 index11 alt1"><code class="keyword bold">struct</code> <code class="plain">node *newNode(</code><code class="color1 bold">int</code> <code class="plain">item) </code></div>
<div class="line number13 index12 alt2"><code class="plain">{ </code></div>
<div class="line number14 index13 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">node *temp =&nbsp; (</code><code class="keyword bold">struct</code> <code class="plain">node *)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">node)); </code></div>
<div class="line number15 index14 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">temp-&gt;key = item; </code></div>
<div class="line number16 index15 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">temp-&gt;left = temp-&gt;right = NULL; </code></div>
<div class="line number17 index16 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">temp; </code></div>
<div class="line number18 index17 alt1"><code class="plain">} </code></div>
<div class="line number19 index18 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number20 index19 alt1"><code class="comments">// A utility function to do inorder traversal of BST </code></div>
<div class="line number21 index20 alt2"><code class="keyword bold">void</code> <code class="plain">inorder(</code><code class="keyword bold">struct</code> <code class="plain">node *root) </code></div>
<div class="line number22 index21 alt1"><code class="plain">{ </code></div>
<div class="line number23 index22 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(root != NULL) </code></div>
<div class="line number24 index23 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code></div>
<div class="line number25 index24 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">inorder(root-&gt;left); </code></div>
<div class="line number26 index25 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d \n"</code><code class="plain">, root-&gt;key); </code></div>
<div class="line number27 index26 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">inorder(root-&gt;right); </code></div>
<div class="line number28 index27 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code></div>
<div class="line number29 index28 alt2"><code class="plain">} </code></div>
<div class="line number30 index29 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number31 index30 alt2 highlighted"><code class="comments">/* A utility function to insert a new node with given key in BST */</code></div>
<div class="line number32 index31 alt1 highlighted"><code class="keyword bold">struct</code> <code class="plain">node* insert(</code><code class="keyword bold">struct</code> <code class="plain">node* node, </code><code class="color1 bold">int</code> <code class="plain">key) </code></div>
<div class="line number33 index32 alt2 highlighted"><code class="plain">{ </code></div>
<div class="line number34 index33 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* If the tree is empty, return a new node */</code></div>
<div class="line number35 index34 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(node == NULL) </code><code class="keyword bold">return</code> <code class="plain">newNode(key); </code></div>
<div class="line number36 index35 alt1 highlighted"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number37 index36 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Otherwise, recur down the tree */</code></div>
<div class="line number38 index37 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(key &lt; node-&gt;key) </code></div>
<div class="line number39 index38 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">node-&gt;left&nbsp; = insert(node-&gt;left, key); </code></div>
<div class="line number40 index39 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(key &gt; node-&gt;key) </code></div>
<div class="line number41 index40 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">node-&gt;right = insert(node-&gt;right, key);&nbsp;&nbsp;&nbsp; </code></div>
<div class="line number42 index41 alt1 highlighted"><code class="undefined spaces">&nbsp;</code>&nbsp;</div>
<div class="line number43 index42 alt2 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* return the (unchanged) node pointer */</code></div>
<div class="line number44 index43 alt1 highlighted"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">node; </code></div>
<div class="line number45 index44 alt2 highlighted"><code class="plain">} </code></div>
<div class="line number46 index45 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number47 index46 alt2"><code class="comments">// Driver Program to test above functions </code></div>
<div class="line number48 index47 alt1"><code class="color1 bold">int</code> <code class="plain">main() </code></div>
<div class="line number49 index48 alt2"><code class="plain">{ </code></div>
<div class="line number50 index49 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Let us create following BST </code></div>
<div class="line number51 index50 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">50 </code></div>
<div class="line number52 index51 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/&nbsp;&nbsp;&nbsp;&nbsp; \ </code></div>
<div class="line number53 index52 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 70 </code></div>
<div class="line number54 index53 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/&nbsp; \&nbsp;&nbsp;&nbsp; /&nbsp; \ </code></div>
<div class="line number55 index54 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">20&nbsp;&nbsp; 40&nbsp; 60&nbsp;&nbsp; 80 */</code></div>
<div class="line number56 index55 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">node *root = NULL; </code></div>
<div class="line number57 index56 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">root = insert(root, 50); </code></div>
<div class="line number58 index57 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">insert(root, 30); </code></div>
<div class="line number59 index58 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">insert(root, 20); </code></div>
<div class="line number60 index59 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">insert(root, 40); </code></div>
<div class="line number61 index60 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">insert(root, 70); </code></div>
<div class="line number62 index61 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">insert(root, 60); </code></div>
<div class="line number63 index62 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">insert(root, 80); </code></div>
<div class="line number64 index63 alt1"><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number65 index64 alt2"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print inoder traversal of the BST </code></div>
<div class="line number66 index65 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">inorder(root); </code></div>
<div class="line number67 index66 alt2"><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number68 index67 alt1"><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code></div>
<div class="line number69 index68 alt2"><code class="plain">} </code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<br /><strong>Output:</strong>
<pre>20
30
40
50
60
70
80</pre>
<p><strong>Illustration to insert 2 in below tree:</strong><br />1. Start from root.<br />2. Compare the inserting element with root, if less than root, then recurse for left, else recurse for right.<br />3. After reaching end,just insert that node at left(if less than current) else right.<br /><img class="aligncenter size-full wp-image-27861" src="https://media.geeksforgeeks.org/wp-content/uploads/BSTSearch.png" alt="bstsearch" /><br /><strong>Time Complexity:&nbsp;</strong>The worst case time complexity of search and insert operations is O(h) where h is height of Binary Search Tree. In worst case, we may have to travel from root to the deepest leaf node. The height of a skewed tree may become n and the time complexity of search and insert operation may become O(n).</p>
</div>
</div>
</div>
</div>
</div>
